/*
描述
给出一个整数数组 和有序的整数数组 ，请将数组 合并到数组 中，变成一个有序的升序数组
注意：
1.可以假设 数组有足够的空间存放 数组的元素， 和 中初始的元素数目分别为 和 ，的数组空间大小为 +
2.不要返回合并的数组，返回是空的，将数组 的数据合并到里面就好了
3.数组在[0,m-1]的范围也是有序的

例1:
A: [4,5,6,0,0,0]，m=3
B: [1,2,3]，n=3
合并过后A为:A: [1,2,3,4,5,6]

示例1
输入：[4,5,6],[1,2,3]
返回值：
[1,2,3,4,5,6]
说明：A数组为[4,5,6]，B数组为[1,2,3]，后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，将B的数据合并A里面，最后后台程序输出A数组
示例2
输入：[1,2,3],[2,5,6]
返回值：
[1,2,2,3,5,6]
*/

package main

import "fmt"

func main() {
	A1 := make([]int, 6)
	A1[0] = 4
	A1[1] = 5
	A1[2] = 6

	B1 := make([]int, 3)
	B1[0] = 1
	B1[1] = 2
	B1[2] = 3

	merge(A1, 3, B1, 3)
	fmt.Println("A1:", A1)
}

/**
 *
 * @param A int整型一维数组
 * @param B int整型一维数组
 * @return void
 */
//两种方法，一种是通过中间变量，将数据排序到一个新数组
//2.倒叙遍历，最后得到的数组就是符合要求的
func merge(A []int, m int, B []int, n int) {
	// write code here
	//其实不用ij两个新变量，直接用mn就可以，值类型参数改变不会影响原值
	for i, j := m-1, n-1; i >= 0 || j >= 0; {
		//fmt.Println("i:", i, ";j:", j)
		// if i < 0 {
		// 	fmt.Println("A:", A, ";B:", B)
		// 	A = append(B[0:j+1], A[j:]...)//append后A指向了一个新的地址，而函数结束后这个新地址不会被带出，所以不能这样做。可以传切片指针，或对A一步步进行赋值
		// 	j = -1
		// }
		if i < 0 { //这种情况可以再后面处理。
			A[j] = B[j]
			j--
		} else if j < 0 { //这时候A就已经是符合要求的了
			i = -1
			break
		} else if A[i] > B[j] {
			A[i+j+1] = A[i]
			i--
		} else {
			A[i+j+1] = B[j]
			j--
		}
	}
}
